#!/usr/bin/env python
# coding: utf-8

# In[23]:


# Setup: Ensure NLTK and spaCy resources are available
import sys
import subprocess
subprocess.run([sys.executable, '-m', 'pip', 'install', 'nltk', 'spacy'])
import nltk
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('punkt_tab')
import spacy
subprocess.run([sys.executable, '-m', 'spacy', 'download', 'en_core_web_sm'])
nlp = spacy.load('en_core_web_sm')


# # Mood Miner â€“ All-in-One Executable Notebook
# This notebook builds the emotion classifier and provides a chat interface powered by Gemini API.

# In[ ]:


# Import Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import nltk
import spacy
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
import joblib
nltk.download('stopwords')
nltk.download('punkt')
nltk.download('punkt_tab')
nlp = spacy.load('en_core_web_sm')


# ## Load Dataset
# Place your dataset files (`train.txt`, `val.txt`, `test.txt`) in the `data/` folder. Each file should have two columns: `text` and `emotion`, separated by a tab.

# In[ ]:


import pandas as pd
import os
def load_txt(path):
    # Each line: <text>;<emotion>
    data = []
    with open(path, encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if ';' in line:
                text, emotion = line.rsplit(';', 1)
                data.append({'text': text.strip(), 'emotion': emotion.strip()})
    return pd.DataFrame(data)
train_path = os.path.join('data', 'train.txt')
val_path = os.path.join('data', 'val.txt')
test_path = os.path.join('data', 'test.txt')
train_df = load_txt(train_path)
val_df = load_txt(val_path)
test_df = load_txt(test_path)
df = pd.concat([train_df, val_df], ignore_index=True)
print('Train/Val shape:', df.shape)
print('Test shape:', test_df.shape)
df.head()


# ## Preprocessing
# Lowercase, remove punctuation, tokenize, remove stopwords, lemmatize.

# In[ ]:


import string

def preprocess(text):

    text = text.lower()

    text = ''.join([c for c in text if c not in string.punctuation])

    doc = nlp(text)

    tokens = [token.lemma_ for token in doc if not token.is_stop and not token.is_punct and token.lemma_ != '-PRON-' and token.lemma_.strip() != '']

    return ' '.join(tokens)


df['clean_text'] = df['text'].apply(preprocess)

test_df['clean_text'] = test_df['text'].apply(preprocess)

print(df[['text', 'clean_text']].head())

print(test_df[['text', 'clean_text']].head())


# ## TF-IDF Vectorization
# Convert cleaned text to TF-IDF features.

# In[ ]:


vectorizer = TfidfVectorizer()
X = vectorizer.fit_transform(df['clean_text'])
y = df['emotion']
X_test = vectorizer.transform(test_df['clean_text'])
y_test = test_df['emotion']
print('Train/Val features shape:', X.shape)
print('Test features shape:', X_test.shape)


# ## Model Training
# Train a Logistic Regression classifier.

# In[ ]:


model = LogisticRegression(max_iter=1000, solver='saga', random_state=42)
model.fit(X, y)


# ## Evaluation
# Check accuracy and confusion matrix.

# In[ ]:


y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))
conf_matrix = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8,6))
plt.imshow(conf_matrix, cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.colorbar()
plt.show()


# ## Save Model
# Save trained model and vectorizer for later use.

# In[ ]:


joblib.dump(model, 'model.pkl')
joblib.dump(vectorizer, 'vectorizer.pkl')


# ## Final Testing Cell
# Test the model on a custom input.

# In[ ]:


def predict_emotion(text):
    cleaned = preprocess(text)
    print('Preprocessed:', cleaned)
    vect = vectorizer.transform([cleaned])
    probs = model.predict_proba(vect)[0]
    max_prob = np.max(probs)
    threshold = 0.5  # Tune as needed
    if max_prob < threshold:
        return 'neutral'
    return model.classes_[np.argmax(probs)]

sample_text = 'i was in shocked whem i found out that you wre in the hospital'
predicted = predict_emotion(sample_text)
print(f'Predicted emotion: {predicted}')
if predicted == 'neutral':
    print('No strong emotion detected; only echo user query in chat app. All suggestions are generated by LLM.')

